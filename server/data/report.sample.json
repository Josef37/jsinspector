[{"id":"5c0d791a21efb555d018db47d74489f898b37829","instances":[{"path":"..\\src\\expression\\node\\Node.js","lines":[240,260],"code":"Node.prototype.toString = function (options) {\n  let customString\n  if (options && typeof options === 'object') {\n    switch (typeof options.handler) {\n      case 'object':\n      case 'undefined':\n        break\n      case 'function':\n        customString = options.handler(this, options)\n        break\n      default:\n        throw new TypeError('Object or function expected as callback')\n    }\n  }\n\n  if (typeof customString !== 'undefined') {\n    return customString\n  }\n\n  return this._toString(options)\n}"},{"path":"..\\src\\expression\\node\\Node.js","lines":[287,307],"code":"Node.prototype.toHTML = function (options) {\n  let customString\n  if (options && typeof options === 'object') {\n    switch (typeof options.handler) {\n      case 'object':\n      case 'undefined':\n        break\n      case 'function':\n        customString = options.handler(this, options)\n        break\n      default:\n        throw new TypeError('Object or function expected as callback')\n    }\n  }\n\n  if (typeof customString !== 'undefined') {\n    return customString\n  }\n\n  return this.toHTML(options)\n}"}]},
{"id":"8bbb8b0b66cf5117c92dd5d0dfeec657c1741e4e","instances":[{"path":"..\\src\\expression\\transform\\diff.transform.js","lines":[18,31],"code":"return typed(name, {\n  '...any': function (args) {\n    // change last argument dim from one-based to zero-based\n    if (args.length === 2 && isCollection(args[0])) {\n      const dim = args[1]\n      if (isNumber(dim)) {\n        args[1] = dim - 1\n      } else if (isBigNumber(dim)) {\n        args[1] = dim.minus(1)\n      }\n    }\n\n    try {\n      return diff.apply(null, args)"},{"path":"..\\src\\expression\\transform\\max.transform.js","lines":[19,32],"code":"return typed('max', {\n  '...any': function (args) {\n    // change last argument dim from one-based to zero-based\n    if (args.length === 2 && isCollection(args[0])) {\n      const dim = args[1]\n      if (isNumber(dim)) {\n        args[1] = dim - 1\n      } else if (isBigNumber(dim)) {\n        args[1] = dim.minus(1)\n      }\n    }\n\n    try {\n      return max.apply(null, args)"},{"path":"..\\src\\expression\\transform\\mean.transform.js","lines":[19,32],"code":"return typed('mean', {\n  '...any': function (args) {\n    // change last argument dim from one-based to zero-based\n    if (args.length === 2 && isCollection(args[0])) {\n      const dim = args[1]\n      if (isNumber(dim)) {\n        args[1] = dim - 1\n      } else if (isBigNumber(dim)) {\n        args[1] = dim.minus(1)\n      }\n    }\n\n    try {\n      return mean.apply(null, args)"},{"path":"..\\src\\expression\\transform\\min.transform.js","lines":[19,32],"code":"return typed('min', {\n  '...any': function (args) {\n    // change last argument dim from one-based to zero-based\n    if (args.length === 2 && isCollection(args[0])) {\n      const dim = args[1]\n      if (isNumber(dim)) {\n        args[1] = dim - 1\n      } else if (isBigNumber(dim)) {\n        args[1] = dim.minus(1)\n      }\n    }\n\n    try {\n      return min.apply(null, args)"},{"path":"..\\src\\expression\\transform\\std.transform.js","lines":[19,32],"code":"return typed('std', {\n  '...any': function (args) {\n    // change last argument dim from one-based to zero-based\n    if (args.length >= 2 && isCollection(args[0])) {\n      const dim = args[1]\n      if (isNumber(dim)) {\n        args[1] = dim - 1\n      } else if (isBigNumber(dim)) {\n        args[1] = dim.minus(1)\n      }\n    }\n\n    try {\n      return std.apply(null, args)"},{"path":"..\\src\\expression\\transform\\sum.transform.js","lines":[19,32],"code":"return typed(name, {\n  '...any': function (args) {\n    // change last argument dim from one-based to zero-based\n    if (args.length === 2 && isCollection(args[0])) {\n      const dim = args[1]\n      if (isNumber(dim)) {\n        args[1] = dim - 1\n      } else if (isBigNumber(dim)) {\n        args[1] = dim.minus(1)\n      }\n    }\n\n    try {\n      return sum.apply(null, args)"},{"path":"..\\src\\expression\\transform\\variance.transform.js","lines":[19,32],"code":"return typed(name, {\n  '...any': function (args) {\n    // change last argument dim from one-based to zero-based\n    if (args.length >= 2 && isCollection(args[0])) {\n      const dim = args[1]\n      if (isNumber(dim)) {\n        args[1] = dim - 1\n      } else if (isBigNumber(dim)) {\n        args[1] = dim.minus(1)\n      }\n    }\n\n    try {\n      return variance.apply(null, args)"}]},
{"id":"19f2ca8cf6cf1b26d9b075c29e313b018a752774","instances":[{"path":"..\\src\\function\\arithmetic\\multiply.js","lines":[345,368],"code":"let dt\n// addScalar signature to use\nlet af = addScalar\n// multiplyScalar signature to use\nlet mf = multiplyScalar\n// equalScalar signature to use\nlet eq = equalScalar\n// zero value\nlet zero = 0\n\n// process data types\nif (adt && bdt && adt === bdt && typeof adt === 'string') {\n  // datatype\n  dt = adt\n  // find signatures that matches (dt, dt)\n  af = typed.find(addScalar, [dt, dt])\n  mf = typed.find(multiplyScalar, [dt, dt])\n  eq = typed.find(equalScalar, [dt, dt])\n  // convert 0 to the same datatype\n  zero = typed.convert(0, dt)\n}\n\n// result\nconst cvalues = []"},{"path":"..\\src\\function\\arithmetic\\multiply.js","lines":[456,479],"code":"let dt\n// addScalar signature to use\nlet af = addScalar\n// multiplyScalar signature to use\nlet mf = multiplyScalar\n// equalScalar signature to use\nlet eq = equalScalar\n// zero value\nlet zero = 0\n\n// process data types\nif (adt && bdt && adt === bdt && typeof adt === 'string') {\n  // datatype\n  dt = adt\n  // find signatures that matches (dt, dt)\n  af = typed.find(addScalar, [dt, dt])\n  mf = typed.find(multiplyScalar, [dt, dt])\n  eq = typed.find(equalScalar, [dt, dt])\n  // convert 0 to the same datatype\n  zero = typed.convert(0, dt)\n}\n\n// workspace\nconst x = []"},{"path":"..\\src\\function\\arithmetic\\multiply.js","lines":[555,578],"code":"let dt\n// addScalar signature to use\nlet af = addScalar\n// multiplyScalar signature to use\nlet mf = multiplyScalar\n// equalScalar signature to use\nlet eq = equalScalar\n// zero value\nlet zero = 0\n\n// process data types\nif (adt && bdt && adt === bdt && typeof adt === 'string') {\n  // datatype\n  dt = adt\n  // find signatures that matches (dt, dt)\n  af = typed.find(addScalar, [dt, dt])\n  mf = typed.find(multiplyScalar, [dt, dt])\n  eq = typed.find(equalScalar, [dt, dt])\n  // convert 0 to the same datatype\n  zero = typed.convert(0, dt)\n}\n\n// result\nconst cvalues = []"}]},
{"id":"23a49e612d99aa84dd6f9ffecaf4ff18584a9106","instances":[{"path":"..\\src\\expression\\node\\RelationalNode.js","lines":[105,112],"code":"RelationalNode.prototype._toString = function (options) {\n  const parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep'\n  const precedence = getPrecedence(this, parenthesis)\n\n  const paramStrings = this.params.map(function (p, index) {\n    const paramPrecedence = getPrecedence(p, parenthesis)\n    return (parenthesis === 'all' || (paramPrecedence !== null && paramPrecedence <= precedence))\n      ? '(' + p.toString(options) + ')'"},{"path":"..\\src\\expression\\node\\RelationalNode.js","lines":[161,168],"code":"RelationalNode.prototype.toHTML = function (options) {\n  const parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep'\n  const precedence = getPrecedence(this, parenthesis)\n\n  const paramStrings = this.params.map(function (p, index) {\n    const paramPrecedence = getPrecedence(p, parenthesis)\n    return (parenthesis === 'all' || (paramPrecedence !== null && paramPrecedence <= precedence))\n      ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>'"},{"path":"..\\src\\expression\\node\\RelationalNode.js","lines":[194,201],"code":"RelationalNode.prototype._toTex = function (options) {\n  const parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep'\n  const precedence = getPrecedence(this, parenthesis)\n\n  const paramStrings = this.params.map(function (p, index) {\n    const paramPrecedence = getPrecedence(p, parenthesis)\n    return (parenthesis === 'all' || (paramPrecedence !== null && paramPrecedence <= precedence))\n      ? '\\\\left(' + p.toTex(options) + '\\right)'"}]},
{"id":"b96470aaba7798b82906f6bc6d19fad9b7db123a","instances":[{"path":"..\\src\\function\\algebra\\solver\\lsolveAll.js","lines":[87,105],"code":"} else if (!equalScalar(b[i], 0)) {\n  // singular row, nonzero RHS\n\n  if (k === 0) {\n    // There is no valid solution\n    return []\n  } else {\n    // This RHS is invalid but other solutions may still exist\n    B.splice(k, 1)\n    k -= 1\n    L -= 1\n  }\n} else if (k === 0) {\n  // singular row, RHS is zero\n\n  const bNew = [...b]\n  bNew[i] = 1\n\n  for (let j = i + 1; j < columns; j++) {"},{"path":"..\\src\\function\\algebra\\solver\\lsolveAll.js","lines":[167,185],"code":"} else if (!equalScalar(b[i], 0)) {\n  // singular row, nonzero RHS\n\n  if (k === 0) {\n    // There is no valid solution\n    return []\n  } else {\n    // This RHS is invalid but other solutions may still exist\n    B.splice(k, 1)\n    k -= 1\n    L -= 1\n  }\n} else if (k === 0) {\n  // singular row, RHS is zero\n\n  const bNew = [...b]\n  bNew[i] = 1\n\n  for (let j = 0, lastIndex = iIndices.length; j < lastIndex; j++) {"},{"path":"..\\src\\function\\algebra\\solver\\usolveAll.js","lines":[87,105],"code":"} else if (!equalScalar(b[i], 0)) {\n  // singular row, nonzero RHS\n\n  if (k === 0) {\n    // There is no valid solution\n    return []\n  } else {\n    // This RHS is invalid but other solutions may still exist\n    B.splice(k, 1)\n    k -= 1\n    L -= 1\n  }\n} else if (k === 0) {\n  // singular row, RHS is zero\n\n  const bNew = [...b]\n  bNew[i] = 1\n\n  for (let j = i - 1; j >= 0; j--) {"},{"path":"..\\src\\function\\algebra\\solver\\usolveAll.js","lines":[168,187],"code":"} else if (!equalScalar(b[i], 0)) {\n  // singular row, nonzero RHS\n\n  if (k === 0) {\n    // There is no valid solution\n    return []\n  } else {\n    // This RHS is invalid but other solutions may still exist\n    B.splice(k, 1)\n    k -= 1\n    L -= 1\n  }\n} else if (k === 0) {\n  // singular row, RHS is zero\n\n  const bNew = [...b]\n  bNew[i] = 1\n\n  // loop upper triangular\n  for (let j = 0, lastIndex = iIndices.length; j < lastIndex; j++) {"}]},
{"id":"bcd39f911a3aaa7a5d7a4b1d147eee472c2532a2","instances":[{"path":"..\\src\\utils\\collection.js","lines":[156,166],"code":"if (x) {\n  // values in j\n  for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n    // row\n    i = aindex[k]\n    // check value exists in current j\n    if (w[i] !== mark) {\n      // i is new entry in j\n      w[i] = mark\n      // add i to pattern of C\n      cindex.push(i)"},{"path":"..\\src\\utils\\collection.js","lines":[184,194],"code":"} else {\n  // values in j\n  for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n    // row\n    i = aindex[k]\n    // check value exists in current j\n    if (w[i] !== mark) {\n      // i is new entry in j\n      w[i] = mark\n      // add i to pattern of C\n      cindex.push(i)"}]},
{"id":"c81ff268315cec18450bfb62a8903e6e75ad12ba","instances":[{"path":"..\\src\\type\\matrix\\DenseMatrix.js","lines":[709,758],"code":"// validate k if any\nif (k) {\n  // convert BigNumber to a number\n  if (isBigNumber(k)) { k = k.toNumber() }\n  // is must be an integer\n  if (!isNumber(k) || !isInteger(k)) {\n    throw new TypeError('The parameter k must be an integer number')\n  }\n} else {\n  // default value\n  k = 0\n}\n\nconst kSuper = k > 0 ? k : 0\nconst kSub = k < 0 ? -k : 0\n\n// rows and columns\nconst rows = size[0]\nconst columns = size[1]\n\n// number of non-zero items\nconst n = Math.min(rows - kSub, columns - kSuper)\n\n// value extraction function\nlet _value\n\n// check value\nif (isArray(value)) {\n  // validate array\n  if (value.length !== n) {\n    // number of values in array must be n\n    throw new Error('Invalid value array length')\n  }\n  // define function\n  _value = function (i) {\n    // return value @ i\n    return value[i]\n  }\n} else if (isMatrix(value)) {\n  // matrix size\n  const ms = value.size()\n  // validate matrix\n  if (ms.length !== 1 || ms[0] !== n) {\n    // number of values in array must be n\n    throw new Error('Invalid matrix length')\n  }\n  // define function\n  _value = function (i) {\n    // return value @ i\n    return value.get([i])"},{"path":"..\\src\\type\\matrix\\SparseMatrix.js","lines":[1217,1257],"code":"  // convert 0 to the same datatype\n  zero = typed.convert(0, datatype)\n}\n\nconst kSuper = k > 0 ? k : 0\nconst kSub = k < 0 ? -k : 0\n\n// rows and columns\nconst rows = size[0]\nconst columns = size[1]\n\n// number of non-zero items\nconst n = Math.min(rows - kSub, columns - kSuper)\n\n// value extraction function\nlet _value\n\n// check value\nif (isArray(value)) {\n  // validate array\n  if (value.length !== n) {\n    // number of values in array must be n\n    throw new Error('Invalid value array length')\n  }\n  // define function\n  _value = function (i) {\n    // return value @ i\n    return value[i]\n  }\n} else if (isMatrix(value)) {\n  // matrix size\n  const ms = value.size()\n  // validate matrix\n  if (ms.length !== 1 || ms[0] !== n) {\n    // number of values in array must be n\n    throw new Error('Invalid matrix length')\n  }\n  // define function\n  _value = function (i) {\n    // return value @ i\n    return value.get([i])"}]},
{"id":"f5a3d49c0d7e811502684627fb6799d88d3d057c","instances":[{"path":"..\\src\\function\\arithmetic\\multiply.js","lines":[713,723],"code":"if (values) {\n  // loop values in a[:,ib]\n  for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n    // row\n    ia = aindex[ka]\n    // check value exists in current j\n    if (w[ia] !== mark) {\n      // ia is new entry in j\n      w[ia] = mark\n      // add i to pattern of C\n      cindex.push(ia)"},{"path":"..\\src\\function\\arithmetic\\multiply.js","lines":[731,741],"code":"} else {\n  // loop values in a[:,ib]\n  for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n    // row\n    ia = aindex[ka]\n    // check value exists in current j\n    if (w[ia] !== mark) {\n      // ia is new entry in j\n      w[ia] = mark\n      // add i to pattern of C\n      cindex.push(ia)"}]}]
